import pygame
import random
import sys
from typing import Set, Tuple, List, Dict

# Инициализация Pygame
pygame.init()

# Константы
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
DARK_GREEN = (0, 200, 0)
BLUE = (0, 0, 255)

CELL_SIZE = 20
GRID_WIDTH = 32
GRID_HEIGHT = 24
SCREEN_WIDTH = CELL_SIZE * GRID_WIDTH
SCREEN_HEIGHT = CELL_SIZE * GRID_HEIGHT
FPS = 20

# Предварительные вычисления
CENTER_X = SCREEN_WIDTH // 2
CENTER_Y = SCREEN_HEIGHT // 2
CENTER_POSITION = (CENTER_X, CENTER_Y)

# Все возможные ячейки поля
ALL_CELLS = set((x * CELL_SIZE, y * CELL_SIZE) 
                for x in range(GRID_WIDTH) 
                for y in range(GRID_HEIGHT))

# Словарь для управления направлением
DIRECTION_MAP = {
    (pygame.K_UP, (CELL_SIZE, 0)): (0, -CELL_SIZE),
    (pygame.K_UP, (-CELL_SIZE, 0)): (0, -CELL_SIZE),
    (pygame.K_UP, (0, CELL_SIZE)): (0, -CELL_SIZE),
    (pygame.K_UP, (0, -CELL_SIZE)): (0, -CELL_SIZE),
    
    (pygame.K_DOWN, (CELL_SIZE, 0)): (0, CELL_SIZE),
    (pygame.K_DOWN, (-CELL_SIZE, 0)): (0, CELL_SIZE),
    (pygame.K_DOWN, (0, CELL_SIZE)): (0, CELL_SIZE),
    (pygame.K_DOWN, (0, -CELL_SIZE)): (0, CELL_SIZE),
    
    (pygame.K_LEFT, (CELL_SIZE, 0)): (-CELL_SIZE, 0),
    (pygame.K_LEFT, (-CELL_SIZE, 0)): (-CELL_SIZE, 0),
    (pygame.K_LEFT, (0, CELL_SIZE)): (-CELL_SIZE, 0),
    (pygame.K_LEFT, (0, -CELL_SIZE)): (-CELL_SIZE, 0),
    
    (pygame.K_RIGHT, (CELL_SIZE, 0)): (CELL_SIZE, 0),
    (pygame.K_RIGHT, (-CELL_SIZE, 0)): (CELL_SIZE, 0),
    (pygame.K_RIGHT, (0, CELL_SIZE)): (CELL_SIZE, 0),
    (pygame.K_RIGHT, (0, -CELL_SIZE)): (CELL_SIZE, 0),
}


class GameObject:
    """Базовый класс для всех игровых объектов"""
    
    def __init__(self, position: Tuple[int, int] = CENTER_POSITION):
        """
        Инициализирует игровой объект
        
        Args:
            position: начальная позиция объекта
        """
        self.position = position
        self.body_color = BLACK  # По умолчанию черный
    
    def draw_cell(self, surface: pygame.Surface, position: Tuple[int, int], 
                 color: Tuple[int, int, int], border: bool = True) -> None:
        """
        Отрисовывает одну ячейку на поверхности
        
        Args:
            surface: поверхность для отрисовки
            position: позиция ячейки
            color: цвет заливки
            border: рисовать ли границу
        """
        rect = pygame.Rect(position[0], position[1], CELL_SIZE, CELL_SIZE)
        pygame.draw.rect(surface, color, rect)
        if border:
            pygame.draw.rect(surface, WHITE, rect, 1)
    
    def draw(self, surface: pygame.Surface) -> None:
        """Абстрактный метод для отрисовки объекта"""
        pass


class Apple(GameObject):
    """Класс для яблока в игре Змейка"""
    
    def __init__(self):
        """Инициализирует яблоко со случайной позицией"""
        super().__init__()
        self.body_color = RED
        self.randomize_position(set())
    
    def randomize_position(self, occupied_cells: Set[Tuple[int, int]]) -> None:
        """
        Устанавливает случайную позицию для яблока
        
        Args:
            occupied_cells: множество занятых ячеек
        """
        free_cells = ALL_CELLS - occupied_cells
        if free_cells:
            self.position = random.choice(tuple(free_cells))
        else:
            # Если нет свободных ячеек, ставим в первую попавшуюся
            self.position = (0, 0)
    
    def draw(self, surface: pygame.Surface) -> None:
        """Отрисовывает яблоко на игровой поверхности"""
        self.draw_cell(surface, self.position, self.body_color)


class Snake(GameObject):
    """Класс для змейки в игре Змейка"""
    
    def __init__(self):
        """Инициализирует змейку в начальном состоянии"""
        super().__init__()
        self.body_color = GREEN
        self.reset()
    
    def reset(self) -> None:
        """Сбрасывает змейку в начальное состояние"""
        self.length = 1
        self.positions = [CENTER_POSITION]
        self.direction = (CELL_SIZE, 0)  # Начальное направление: вправо
        self.next_direction = None
        self.grow_pending = False
    
    def update_direction(self) -> None:
        """Обновляет направление движения змейки"""
        if self.next_direction:
            self.direction = self.next_direction
            self.next_direction = None
    
    def move(self) -> None:
        """Обновляет позицию змейки, добавляя новую голову"""
        head_x, head_y = self.positions[0]
        dir_x, dir_y = self.direction
        
        # Новое положение головы с учетом прохождения через стены
        new_x = (head_x + dir_x) % SCREEN_WIDTH
        new_y = (head_y + dir_y) % SCREEN_HEIGHT
        
        new_head = (new_x, new_y)
        self.positions.insert(0, new_head)
        
        # Удаляем хвост, если змейка не должна расти
        if not self.grow_pending and len(self.positions) > self.length:
            self.old_tail = self.positions.pop()
        else:
            self.grow_pending = False
            self.old_tail = None
    
    def grow(self) -> None:
        """Увеличивает длину змейки"""
        self.length += 1
        self.grow_pending = True
    
    def draw(self, surface: pygame.Surface) -> None:
        """Отрисовывает змейку на экране"""
        # Отрисовываем голову другим цветом
        if self.positions:
            self.draw_cell(surface, self.positions[0], DARK_GREEN)
        
        # Отрисовываем тело
        for position in self.positions[1:]:
            self.draw_cell(surface, position, self.body_color)
        
        # Стираем старый хвост
        if self.old_tail:
            self.draw_cell(surface, self.old_tail, BLACK, border=False)
    
    def get_head_position(self) -> Tuple[int, int]:
        """Возвращает позицию головы змейки"""
        return self.positions[0] if self.positions else CENTER_POSITION
    
    def get_occupied_cells(self) -> Set[Tuple[int, int]]:
        """Возвращает множество занятых змейкой ячеек"""
        return set(self.positions)
    
    def check_self_collision(self) -> bool:
        """
        Проверяет столкновение головы с телом
        
        Returns:
            True если произошло столкновение
        """
        # У короткой змейки не может быть столкновения
        if len(self.positions) <= 4:
            return False
        
        head = self.get_head_position()
        return head in self.positions[1:]


def handle_keys(snake: Snake) -> bool:
    """
    Обрабатывает нажатия клавиш
    
    Args:
        snake: объект змейки
        
    Returns:
        False если игра должна завершиться
    """
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            return False
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                return False
            # Обновление направления через словарь
            new_direction = DIRECTION_MAP.get((event.key, snake.direction))
            if new_direction:
                snake.next_direction = new_direction
    return True


def load_high_score() -> int:
    """Загружает рекорд из файла"""
    try:
        with open('snake_high_score.txt', 'r') as f:
            return int(f.read())
    except (FileNotFoundError, ValueError):
        return 0


def save_high_score(score: int) -> None:
    """Сохраняет рекорд в файл"""
    try:
        with open('snake_high_score.txt', 'w') as f:
            f.write(str(score))
    except IOError:
        pass  # Игнорируем ошибки записи


def main():
    """Основная функция игры"""
    # Инициализация экрана
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    
    # Загрузка рекорда
    high_score = load_high_score()
    pygame.display.set_caption(f'Змейка - Рекорд: {high_score}')
    
    clock = pygame.time.Clock()
    
    # Создание игровых объектов
    snake = Snake()
    apple = Apple()
    
    running = True
    while running:
        # Обработка событий
        running = handle_keys(snake)
        if not running:
            break
        
        # Обновление направления змейки
        snake.update_direction()
        
        # Движение змейки
        snake.move()
        
        # Проверка съедания яблока
        if snake.get_head_position() == apple.position:
            snake.grow()
            apple.randomize_position(snake.get_occupied_cells())
            
            # Обновление рекорда
            if snake.length > high_score:
                high_score = snake.length
                pygame.display.set_caption(f'Змейка - Рекорд: {high_score}')
                save_high_score(high_score)
        
        # Проверка столкновения с собой
        if snake.check_self_collision():
            snake.reset()
            apple.randomize_position(snake.get_occupied_cells())
        
        # Отрисовка
        screen.fill(BLACK)
        snake.draw(screen)
        apple.draw(screen)
        pygame.display.update()
        
        # Контроль FPS
        clock.tick(FPS)
    
    pygame.quit()
    sys.exit()


if __name__ == "__main__":
    main()
